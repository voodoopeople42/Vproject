#! /usr/bin/env python
# coding: utf

var = "string1"
print(var) # Выведет "string1"
var = 1
print(var) # Выведет "1"
var += 2
print(var) # Выведет "3"

# число π
PI = 3.14
print(PI)  # => 3.14

# случайное изменение значения
PI='MAIN'
print(PI)

type(object)  # <class 'type'>
type(type)  # <class 'type'>
type(int)  # <class 'type'>
type(57)  # <class 'int'>

a = True
type(a) # <class 'bool'>
b = False
type(b) # <class 'bool'>
type(4 > 5) # <class 'bool'>
type(4 + 5) # <class 'int'>


int(True) # 1
int(False) # 0
# Возможно и обратное. Можно преобразовать какое-либо значение к булевому типу:
bool(3.4) # True
bool(-150) # True
# И здесь работает правило: всё, что не 0 и не пустота, является правдой:
bool(0) # False
bool(' ') # True
bool('') # False

# Обратите внимание на разницу между операторами = и ==.
x = y   # Оператор присваивания. Устанавливает равенство между x и y (то есть присваивает x значение y).
x == y  # Оператор сравнения. Проверяет равенство между x и y и оценивает выражение как истинное или ложное. Выражение истинно, если x и y равны.

x = 2
y = 5
print("x == y:", x == y)
print("x != y:", x != y)
print("x < y:", x < y)
print("x > y:", x > y)
print("x <= y:", x <= y)
print("x >= y:", x >= y)


x == y: False
x != y: True
x < y: True
x > y: False
x <= y: True
x >= y: False

# Операторы сравнения можно применять к логическим значениям True и False:
t = True
f = False
print("t != f: ", t != f) # t != f:  True

# Логические операторы обычно используются для оценки двух или более выражений. 
print((9 > 7) and (2 < 4))  # Оба выражения истинны (True)
print((8 == 8) or (6 != 6)) # Одно из выражений истинно (True)
print(not(3 <= 1))          # Выражение ложно (False)

type(1) # <class 'int'>
isinstance(1, int) # True

# Функция int() отбрасывает дробную часть числа, а не округляет его.
int(2.5) # 2

# Функция int() округляет отрицательные числа в сторону увеличения. Она не возвращает целую часть числа, как делает функция floor (пол), а просто отбрасывает дробную часть.
int(-2.5) # -2

print(255 + 34) # 289
print(20 / 3) # 6.666666666666667
print(3 ** 150) # 369988485035126972924700782451696644186473100389722973815184405301748249

# Точность чисел с плавающей точкой равна 15 десятичным знакам в дробной части.
print(1.12345678901234567890) # 1.1234567890123457

# Python 3 имеет только один целочисленный тип
# Целые числа могут быть сколь угодно большими.
type(1000000000000000) # <class 'int'>

# Теперь попробуйте сравнить числа с плавающей точкой.

print((-0.2 > 1.4) and (0.8 < 3.1)) # Одно из выражений ложно (False)
# Поскольку одно из выражений ложно, and вернёт False. Оператор and оценивает выражение как истинное только тогда, когда оба компонента истинны.

print((7.5 == 8.9) or (9.2 != 9.2)) # Оба выражения ложны (False)
# Поскольку оба выражения ложны, оператор or выдаст False.

print(not(-5.7 <= 0.3))             # Выражение истинно (True)
# Поскольку выражение истинно, оператор not вернёт False (not True = False).

# Логические операторы можно объединять в составные выражения:

not((-0.2 > 1.4) and ((0.8 < 3.1) or (0.1 == 0.1)))

# Выражение (0.8 < 3.1) or (0.1 == 0.1) истинно, поскольку оба математических выражения, из которых оно состоит, истинны. Оператор or вернёт True.

# Полученное значение True становится компонентом следующего выражения: (-0.2 > 1.4) and (True). Оператор and выдаст False, потому что выражение -0.2 > 1.4 ложно. (False) and (True) = False.

# Далее оператор not заменит полученное значение False на обратное ему логическое значение: not(False) = True. Значит, результат будет таким: True
